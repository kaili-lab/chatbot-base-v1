# PRD 协作流程指南

通过 AI 协作从粗略想法到专业 PRD 的完整流程总结。

---

## 一、协作阶段

### 阶段 1：目标与动机（1-2 轮对话）

**你需要提供：**
- 为什么做这个项目（求职展示？商业化？学习？）
- 大致想做什么（一两段话描述即可）
- 可能的使用场景

**AI 会做：**
- 理解你的目标，提出澄清问题
- 帮你判断想法的可行性和市场定位

> 经验：不需要一开始就想清楚所有细节，粗略想法就够了，后续对话会逐步细化。

---

### 阶段 2：需求澄清（3-5 轮对话）

**AI 会围绕以下维度提问：**

| 维度 | 典型问题 |
|------|---------|
| 目标用户 | 谁用？单用户还是多租户？ |
| 产品形态 | Web 应用？嵌入式组件？API 服务？ |
| 技术栈 | 框架偏好？数据库选型？部署平台？ |
| MVP 边界 | 最小可用版本包含哪些功能？ |
| 约束条件 | 预算、时间、团队规模？ |

**你需要做：**
- 回答你确定的部分
- 不确定的直接说"不确定"或"你来建议"
- 对 AI 的建议给出你的判断（同意/不同意/想讨论）

> 经验：不要一次回答太多问题，2-4 个一组比较好，避免遗漏。AI 应该在不确定的架构决策上列出选项让你选择，而不是替你决定。

---

### 阶段 3：技术选型讨论（2-3 轮对话）

**需要确认的内容：**
- 完整技术栈清单（框架、UI 库、ORM、认证、部署等）
- 每个选型的理由（尤其是有争议的选择）
- 最佳实践约束（比如 Next.js 的 Server Components 优先原则）

**关键原则：**
- 让 AI 列出技术栈对比表，你来拍板
- 讨论清楚"为什么用 A 而不用 B"
- 确认版本要求（latest 还是特定版本）

> 经验：技术栈确认要完整，包括"小工具"（弹窗库、校验库、主题库等），不要只列主框架。遗漏的工具后续开发时会造成不一致。

---

### 阶段 4：PRD 生成与审阅（1-2 轮对话）

**AI 生成 PRD 后，重点审查：**
- 数据库设计是否合理（字段是否多余？表名是否语义清晰？是否和第三方库的表名冲突？）
- 功能模块是否遗漏
- 实施计划的分阶段是否合理

**常见需要调整的点：**
- 表名/字段名语义不够清晰 → 要求改名
- 某些字段看不出用途 → 要求 AI 解释
- 第三方库（如认证库）的表结构需要 AI 去查文档确认，避免命名冲突
- 状态字段是否必要 → 根据 MVP 复杂度决定

> 经验：PRD 不是写完就结束，审阅阶段往往能发现 2-3 个设计问题，这很正常。

---

## 二、PRD 文档结构

经验证有效的"三合一"格式（产品需求 + 技术规范 + 实施指南）：

```
# 项目名 - PRD

## Context（一句话说明项目背景和目标）

## 1. 产品定义
### 1.1 核心用户场景（一段话描述完整用户旅程）
### 1.2 MVP 功能清单（按模块分组）

## 2. 技术规范
### 2.1 技术栈（表格形式）
### 2.2 框架最佳实践约束
### 2.3 数据库设计（只列业务表，第三方库的表标注"由 XX 管理"）
### 2.4 核心算法/策略说明（需解释为什么选这个方案）
### 2.5 核心流程图
### 2.6 扩展性设计（预留接口）

## 3. 页面结构（路由 + 布局）

## 4. 实施计划（分 Phase，每个 Phase 列具体任务）

## 5. 验证方案（每个 Phase 的验收标准）
```

---

## 三、PRD 之后的工作流

```
PRD 完成
  ↓
PRD → Gemini 生成 UI 效果图
  ↓
PRD + 效果图 → 拆分 task 文档（引用效果图）
  ↓
编写项目 CLAUDE.md（开发规范 + 测试策略）
  ↓
按 task 文档逐个实现
  ↓
每个 Phase 完成后验证
```

---

## 三-A、Task 文档规范

### 设计原则

- **按功能点拆分**，不按 Phase 拆分。每个 task 是一个独立的、AI 可执行的工作单元
- 粒度标准：一个 task 能在一次 AI 会话中完成（通常 1-3 个文件变更）
- 每个 task 包含完整上下文，AI 拿到后能独立执行，不需要反复翻 PRD
- task 之间标注依赖关系，必须按依赖顺序执行

### Task 文档结构

```markdown
# Task [编号]: [功能名称]

## 依赖
- 前置 task：Task X（需要先完成）
- 相关文件：列出会涉及的文件路径

## 需求描述
简要说明做什么、为什么做，从 PRD 中提炼的关键需求点。

## UI 参考
- 参考截图：`docs/ui/xxx.png`
- 与截图的差异说明（如有）

## 实现要点
- 具体的技术实现指引
- 需要注意的边界情况
- 需要遵守的约束（从 CLAUDE.md 中提取的关键项）

## 验证标准

### 预期行为（简单功能）
- 描述输入和预期输出
- 描述用户可见的行为变化

### 需要通过的测试（核心逻辑）
- test: [测试描述，包含输入、操作、预期结果]
- test: [测试描述]

## 完成标志
- [ ] 功能实现
- [ ] 测试通过
- [ ] 无 TypeScript 错误
- [ ] 项目能正常构建（next build）
```

### 验证标准的分层策略

| 功能类型 | 验证方式 | 示例 |
|---------|---------|------|
| 简单 CRUD / UI 交互 | 预期行为描述 | "点击新建文件夹，目录树中出现新节点" |
| 核心业务逻辑 | 测试用例骨架 | "上传 1000 字 md，应生成 2-3 个 chunk" |
| 数据安全/权限 | 测试用例骨架 | "用户 A 看不到用户 B 的文件" |
| 第三方集成 | 预期行为描述 | "填入正确的 API Key 后，测试连接返回成功" |

### 人工前置操作

某些 task 需要你提前准备好环境或资源，AI 工具无法自行完成。在 task 文档中用独立章节标注：

**常见的人工前置操作：**

| 操作 | 说明 |
|------|------|
| 创建数据库实例 | Neon 或本地 Docker，提供 DATABASE_URL |
| 注册第三方服务 | Resend（邮件）、Google OAuth（客户端 ID/Secret）等 |
| 提供 API Key | LLM 中转平台的 baseURL + API Key |
| 配置 DNS/域名 | 部署阶段 |

**在 task 文档中的写法：**
```markdown
## 人工前置操作（AI 执行前，由你手动完成）
1. 在 neon.tech 创建数据库项目
2. 将连接字符串写入 `.env.local`：`DATABASE_URL=postgresql://...`
3. 完成后告知 AI 工具继续执行
```

AI 工具看到此章节后，会等待你确认完成再继续。

### 协作流程

```
AI 基于 PRD 生成 task 文档（含验证标准）
  ↓
你审阅：需求是否正确？验证标准是否有遗漏？
  ↓
有问题的逐个讨论，确认后锁定
  ↓
AI 按 task 逐个执行（遇到"人工前置操作"时暂停等待你）
  ↓
每个 task 完成后对照验证标准检查
```

---

## 四、UI 设计与需求的关系

两种方式各有适用场景，不存在绝对正确的顺序：

| 方式 | 适用场景 | 说明 |
|------|---------|------|
| 先需求后 UI | 对业务逻辑清楚，但不确定长什么样 | 先和 AI 讨论完需求，再用 Gemini 等工具生成 UI |
| 边设计 UI 边讨论需求 | 对业务逻辑也没完全想清楚 | UI 设计本身是一种需求发现手段，设计过程中会暴露之前没想到的需求点 |

> 经验：**UI 设计是需求发现的有效手段**。几乎每次设计完 UI 都会发现之前没意识到的需求（比如文件夹结构、新建笔记、收藏对话等）。不需要追求一次性把需求想完美，接受"PRD → UI → 发现新需求 → 更新 PRD"的迭代循环。

**关于 UI 截图作为实现参考：**
- 截图是方向性参考，不是像素级标准
- PRD 中有文字说明与 UI 截图不一致的地方，以 PRD 为准
- 在 task 文档中用文字注明和截图的差异即可，不需要为了小细节重新生成 UI

---

## 五、注意事项

1. **PRD 是给 AI 看的执行蓝图**，不是传统的业务文档，需要包含技术细节
2. **不要在 PRD 中写未来规划**，除非已经想清楚了，否则需求变了就是无效内容
3. **测试策略不写在 PRD 里**，写在项目的 CLAUDE.md 中，作为开发时的执行约束
4. **第三方库的表结构要查文档确认**，不要凭记忆，避免命名冲突
5. **每次技术选型争议，让 AI 列对比表，你来做最终决定**
